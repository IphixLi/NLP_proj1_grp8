import json
import re
import string
import spacy
import time
from similarity import compute_similarity_for_one_candidate

# TODO: case problems for persons and work of art

# TODO: winner list should be generated by my code
data = json.load(open('gg2013answers.json'))
award_list = list(data['award_data'].keys())

spacy_model = spacy.load('en_core_web_md')

def get_award_keywords(award_list: list) -> dict:
    keyword_to_awards = {}

    for award in award_list:
        spacy_output = spacy_model(award)
        for token in spacy_output:
            # Check if the token is a stopword, punctuation, or short word
            if token.is_stop or token.is_punct or len(token.text) < 3:
                continue
            
            # Check if the token's part-of-speech is one of the desired categories
            if token.pos_ in ["ADJ", "NOUN", "ADV", "VERB"]:
                keyword = token.text.lower()

                if keyword not in keyword_to_awards:
                    keyword_to_awards[keyword] = [award]
                else:
                    keyword_to_awards[keyword].append(award)
       
    return keyword_to_awards

keyword_to_awards = get_award_keywords(award_list)
award_keywords = list(keyword_to_awards.keys())


def find_persons(spacy_output) -> list:
    persons = []
    for ent in spacy_output.ents:
        if ent.label_ == "PERSON" or ent.label_ == "ORG":
            if ent.text.endswith('\'s'):
                persons.append(ent.text[:-2].lower())
            else:
                persons.append(ent.text.lower())
    return persons
            

def find_work_of_art(spacy_output) -> list:
    return [ent.text.lower() for ent in spacy_output.ents if ent.label_ == "WORK_OF_ART" or ent.label_ == "ORG"]


def find_nominees_by_award_keywords(tweet: dict):
    tweet['new_text'] = remove_ceremony(tweet['new_text'])
    award_candidates = {}
    keywords_in_tweet = []
    
    for keyword in award_keywords:
        if keyword in tweet['new_text'].lower():
            for award in keyword_to_awards[keyword]:
                if award not in award_candidates:
                    award_candidates[award] = 1 / len(keyword_to_awards[keyword])
                else:
                    award_candidates[award] += 1 / len(keyword_to_awards[keyword])
            keywords_in_tweet.append(keyword)
    
    if len(award_candidates) == 0 or max(award_candidates.values()) < 0.25 or len(keywords_in_tweet) < 2:
        return
    
    doc = spacy_model(tweet['new_text'])
    persons = find_persons(doc)
    work_of_art = find_work_of_art(doc)
    tweet['persons'] = persons
    tweet['work_of_art'] = work_of_art
    
    keywords_in_tweet = " ".join(keywords_in_tweet)
    possible_awards = sorted(award_candidates.keys(), key=award_candidates.get, reverse=True)[0]
    if award_candidates[possible_awards] < 1:
        possible_awards = ""
    
    if persons and work_of_art:
        if "actor" in keywords_in_tweet.lower() or "actress" in keywords_in_tweet.lower() or "director" in keywords_in_tweet.lower():
            tweet['nominee_candidates'] = persons
        else:
            tweet['nominee_candidates'] = work_of_art
    elif persons:
        tweet['nominee_candidates'] = persons
    else:
        tweet['nominee_candidates'] = work_of_art
    if 'nominee_candidates' in tweet:
        tweet['award_candidates'] = [keywords_in_tweet, possible_awards] if possible_awards else [keywords_in_tweet]
        tweet['aw_map'] = award_candidates
    

def remove_ceremony(sentence):
    # Remove "golden" and "globe(s)" from the sentence
    return re.sub(r'(?i)\bgolden\b|\bglobe?s?\b|\bgoldenglobe?s?\b', '', sentence).strip()

def find_nominees_by_winner(tweet: dict, winner: str, award: str):
    doc = spacy_model(tweet['new_text'])
    persons = find_persons(doc)
    work_of_art = find_work_of_art(doc)
    
    winner = winner.lower()
    
    is_person = winner in persons
    is_work_of_art = winner in work_of_art
    
    if not is_person and not is_work_of_art:
        # print('Winner not found in tweet?')
        # print(f"Winner: {winner}, text: {tweet['new_text']}")
        return False
    if is_person and is_work_of_art:
        # print('Winner is both person and work of art?')
        # print(f"Winner: {winner}, text: {tweet['new_text']}")
        return False
    
    if is_person:
        persons.remove(winner)
        tweet['nominee_candidates'] = persons + tweet.get('nominee_candidates', [])    
        tweet['award_candidates'] = [award] + tweet.get('award_candidates', [])
    if is_work_of_art:
        work_of_art.remove(winner)
        tweet['nominee_candidates'] = work_of_art + tweet.get('nominee_candidates', [])
        tweet['award_candidates'] = [award] + tweet.get('award_candidates', [])
        
    return is_person or is_work_of_art

# suppose if I have already vote the winner for all awards
# then I can check if some nominees and that winner are in the same sentence
def check_winner_and_nominee_in_sentence(tweet: dict):
    sentence = remove_punctuation(tweet['new_text'])
    sentence = sentence.lower()
    for award, details in data['award_data'].items():
        winner = details['winner']
        if winner.lower() in sentence:
            find_nominees_by_winner(tweet, winner, award)

def remove_punctuation(sentence):
    return ''.join([ch for ch in sentence if ch not in string.punctuation])

if __name__ == '__main__':
    tweets = json.load(open("preprocessed_tweets/normal_tweets.json"))
    start_time = time.time()
    for i, tweet in enumerate(tweets):
        if i % 10000 == 0:
            print(f"Processing tweet {i}, elapsed time: {time.time() - start_time}")
        find_nominees_by_award_keywords(tweet)
        check_winner_and_nominee_in_sentence(tweet)
    
    with open("nominees.json", "w") as f:
        json.dump(tweets, f, indent=4)